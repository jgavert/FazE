#version 140
uniform vec4 info; // (halfres.width, halfres.height, time, offset_as_float)
uniform ivec2 offset; // 2x2 kernel offset

out vec4 out_Color;

float time = info.z;
//float time = 0.5;

#define MAX_ITER 300.0
#define EPSILON 0.000005
#define PII 3.1453
// how many reflections
#define MAXREFLECTION 2.0
// how much object reflects light
#define REFLECTIVITY 0.2
// How far rays can travel(applies to first ray only)
#define MAXLENGTH 40000.0
// color to red by iteration multiplier
#define COLORBYITER 0.5
// This multiplies the one intensity of the light
#define LIGHTINTENSITY 3.5
// this is basically resolution multiplier, one pixel is RAYMULTIPLIER*RAYMULTIPLIER amount of rays
#define RAYMULTIPLIER 1.0

vec3 rotateX(vec3 p, float phi) {
  float c = cos(phi);
  float s = sin(phi);
  return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);
}

vec3 rotateY(vec3 p, float phi) {
  float c = cos(phi);
  float s = sin(phi);
  return vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);
}

vec3 rotateZ(vec3 p, float phi) {
  float c = cos(phi);
  float s = sin(phi);
  return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);
}
/////PRIMITIVES///////////////////////////////////////////////////////
// simple floor to the scene


float sFloor (vec3 pos, float y){
  return abs(y-pos.y);
}

float sBall(vec3 pos, float size) {
  return length(pos)-size;
  // pos 3.0, raypos 1.0, size 1.0, expected something between 1-2 result
}

float udBox( vec3 p, vec3 b )
{
  return length(max(abs(p)-b,0.0))-0.01;
}

float revBox( vec3 p, vec3 b )
{
  return length(max(abs(p)-b,0.0));
}
float rotBox( vec3 p, vec3 b )
{
  return udBox(rotateZ(rotateY(p, sin(time*0.1)*PII), cos(time*0.1)*PII), b);
}

float sdHexPrism( vec3 p, vec2 h )
{
    vec3 q = abs(p);
    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);
}

float opRepBox( vec3 p, vec3 c )
{
    vec3 q = mod(p,c)-0.5*c;
    return udBox( q , vec3(0.15) );
}

float opRepPrism( vec3 p, vec3 c )
{
    vec3 q = mod(p,c)-0.5*c;
    return sdHexPrism( rotateX(q,q.x*2.0) , vec2(0.15) );
}
////HELP FUNCTIONS//////////////////////////////////////////////////
//-----------------------------------------------------------------

float opS( float f1, float f2 )
{
  return (f1<f2) ? f1 : f2;
}

vec2 opU( vec2 d1, vec2 d2 )
{
  return (d1.x<d2.x) ? d1 : d2;
}

vec2 map2(vec3 pos) {
  float box = rotBox(pos-vec3(1.0,sin(time*0.3)*0.6,.6), vec3(0.3));
  float ball = sBall(pos-vec3(-.2,0.1,.5),  0.4);
  float ball2 = sBall(pos-vec3(-.2,0.1,-.5),  0.4);
  vec3 rot = rotateX(pos-vec3(-.2,-.5,.0),sin(time*0.2)*PII);
  float prism = sdHexPrism(rot,vec2(0.2));
  vec2 res = vec2(opRepBox(pos-vec3(-4.3,0.2,0.0), vec3(4.0,0.6, .6)),4.0);
  //vec2 res = vec2(box,2.0);
  //res = opU(res, vec2(ball,2.0));
  //res = opU(res, vec2(ball2,1.0));
  //res = opU(res, vec2(prism,4.0));
  //res = opU(res, vec2(opRepBox(pos-vec3(1.0), vec3(0.5)),2.0));
//walls
#ifdef WALLS
  float size = 3.;
  float frontwall = udBox(pos-vec3(.0,.0,size), vec3(size,size,.2));
  float back = udBox(pos-vec3(.0,.0,-size), vec3(size,size,.2));
  float top = udBox(pos-vec3(.0,size,.0), vec3(size,.2,size));
  float bottom = udBox(pos-vec3(.0,-size,.0), vec3(size,.2,size));
  float left = udBox(pos-vec3(size,.0,.0), vec3(.2,size,size));
  float right = udBox(pos-vec3(-size,.0,.0), vec3(.2,size,size));
  res = opU(res, vec2(frontwall, 0.0));
  res = opU(res, vec2(back, 0.0));
  res = opU(res, vec2(top, 0.0));
  res = opU(res, vec2(bottom, 0.0));
  res = opU(res, vec2(left, 0.0));
  res = opU(res, vec2(right, 0.0));
#endif
  //res = opS(res, sBall(pos-vec3(0.2,0.2,1.5), 0.4));
  //res = opS(res, rotBox(pos-vec3(0.0,0.0,2.5), vec3(0.2)));
  return res;
}

vec3 getNor2(vec3 pos)
{
  vec2 e = vec2(EPSILON*100.0, 0.0);
  vec3 nor = vec3(
      map2(pos+e.xyy).x - map2(pos-e.xyy).x,
      map2(pos+e.yxy).x - map2(pos-e.yxy).x,
      map2(pos+e.yyx).x - map2(pos-e.yyx).x );
  return normalize(nor);
}

// this is probably a ball... I hope

//Specify all the objects that exist


vec3 castRay2(vec3 rp, vec3 rd)
{
  vec3 ro = rp;
  vec2 dist = vec2(100000000.0);
  float it=0.0;
  for (float i = 0.0; i<MAX_ITER; i++) {
    it++;
    dist = map2(rp);
    if (dist.x < EPSILON) break;
    rp = rp+rd*dist.x*0.9;
  }
  return vec3(distance(ro,rp), it, dist.y);
}


vec3 shadowray2(vec3 hitSpot, vec3 lightPos) {
  vec3 rd = normalize(lightPos-hitSpot);
  vec3 rp = hitSpot+rd*0.001;

  vec2 dist = vec2(100000000.0);
  float it=0.0;
  for (float i = 0.0; i<MAX_ITER; i++) {
    it++;
    dist = map2(rp);
    dist.x = min(dist.x, distance(rp,lightPos));
    if (dist.x < EPSILON) break;
    rp = rp+rd*dist.x*0.9;
  }
  if (distance(rp,lightPos) > EPSILON)
    return vec3(0.1);
  float lenToLight = distance(hitSpot, lightPos);
  vec3 normal = getNor2(hitSpot);
  vec3 AOL = vec3(1.0);

  float d = abs(dot(rd,normal));
  if (d > 0.0001)
  {
    AOL = pow(d*LIGHTINTENSITY,4.0)/lenToLight+vec3(1.0,1.0,1.0)*0.5;
  }
  return AOL;
}

vec3 getColor(float id)
{
  if (id == 1.0)
    return vec3(1.0,vec2(0.0));
  else if (id == 2.0)
    return vec3(0.0,1.0,0.0);
  else if (id == 3.0)
    return vec3(0.0,0.0,1.0);
  return vec3 (0.2,0.2,0.2);
}

vec4 calcRay(vec3 ro, vec3 rd, vec3 lightPos)
{
  vec3 color = vec3(0.0);
  float reflection = REFLECTIVITY;
  float lightMultiplier = 1.0;
  vec3 res = castRay2(ro, rd);
  float iter = res.y;
  vec3 aol2 = vec3(0.0);
  if (iter < MAX_ITER && res.x < MAXLENGTH)
  {
    for (float i = 0.0; i < MAXREFLECTION; i++)
    {
      // castray found object
      vec3 point = ro+rd*res.x; // hitted point
      vec3 pointNormal = getNor2(point); // surface normal
      vec3 reflectDir = rd - 2.0*pointNormal*dot(rd,pointNormal);
      vec3 aol = shadowray2(point,lightPos); // get the light
      aol2 += aol*getColor(res.z)*lightMultiplier*reflection;
      lightMultiplier = lightMultiplier * reflection;
      res = castRay2(point+reflectDir*0.001, reflectDir);
      ro = point;
      rd = reflectDir;
    }
    color = (aol2 + COLORBYITER*1.0*vec3(iter/MAX_ITER,.0*iter/MAX_ITER,.0*iter/MAX_ITER));
  }
  return vec4(color, iter/MAX_ITER);
}

vec2 getHigherResolutionPos(float x, float y)
{
  vec2 biggerRes = info.xy*RAYMULTIPLIER*2.0; // since we are actually rendering halfResolution
  vec2 fragCord = gl_FragCoord.xy*2.0 + offset; // we will multiply these by 2.0 automatically
  vec2 screenPos = fragCord*RAYMULTIPLIER; //oletus, aina pikseli blokin ylÃ¤vasen
  screenPos.x += x;
  screenPos.y += y;

  //vec2 resolution = info.xy;
  float aspect = biggerRes.x/biggerRes.y;
  vec2 uvUnit = 1.0 / biggerRes.xy;
  vec2 uv = ( screenPos / biggerRes.xy );
  vec2 pos = (uv-0.5);
  pos.x *= aspect;
  pos.y -= 0.0;
  return pos;
}

vec3 getCameraRay(vec3 posi, vec3 dir, vec2 pos) {
  vec3 camera_right = cross(dir, vec3(0.0,1.0,0.0));
  vec3 camera_up = cross(camera_right, dir);
  vec3 image_point = pos.x * camera_right + pos.y*camera_up + posi+dir;
  return normalize(image_point-posi);
}

vec4 castManyRays(vec3 position,vec3 direction)
{
  float rayMulti = RAYMULTIPLIER - 1.0;
  vec3 lightPos = vec3(-5.0,3.0,-1.5);
  vec3 ro = position;
  vec3 camDir = normalize(direction-position);
  vec2 screenPos = gl_FragCoord.xy;
  float epsilon = 0.001;
  float dist = 0.0;
  float colorMultiplier = 1.0 / (pow(rayMulti,2.0) + 2.0*rayMulti + 1.0);
  vec3 mixColor = vec3(0);
  for (float x = 0.0; x <= RAYMULTIPLIER-1.0; x++)
  {
	  for (float y = 0.0; y <= RAYMULTIPLIER-1.0; y++)
	  {
		  vec3 rd = getCameraRay(position, camDir, getHigherResolutionPos(x,y));
      vec4 calculatedRay = calcRay(ro,rd,lightPos);
		  mixColor += colorMultiplier * calculatedRay.rgb;
      dist += calculatedRay.w;
		  screenPos.y+=epsilon;
	  }
	  screenPos.x+=epsilon;
  }
  return vec4(mixColor, dist);
}

void main() {
  vec3 position = vec3(vec3(0.7+sin(time*0.1)*5.8,cos(time*0.5)*0.8,0.99+cos(time*0.1)*5.8));
  vec3 direction = normalize(position + vec3(0.7+sin(time*0.1)*5.8,cos(time*0.5)*0.8,0.99+cos(time*0.1)*5.8));
  vec4 color = castManyRays(position, direction);
  out_Color = color;
}
