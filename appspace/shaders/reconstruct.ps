#version 140

uniform vec4 info; // (target.width, target.height, halfres.width, halfres.height)
uniform ivec2 offset;
uniform sampler2D half_tex;
uniform sampler2D lastframe;

out vec4 out_Color;

ivec3 clampedValues(int v, int minVal, int maxVal)
{
	return ivec3(max(minVal, v-1), v, min(maxVal, v+1));
}

vec4 simpleBlur(sampler2D tex1, vec2 uv)
{
	vec2 tsize = textureSize(tex1, 0);
	ivec2 ac = ivec2(int(uv.x * tsize.x),int(uv.y* tsize.y) );
	ivec3 xv = clampedValues(ac.x, 0, int(tsize.x));
	ivec3 yv = clampedValues(ac.y, 0, int(tsize.y));

	vec4 c = vec4(vec3(0.0), 1.0);
	c += texelFetchOffset(tex1, ivec2(xv.x, yv.x), 0, ivec2(0,0))*1.0/16.0;
	c += texelFetchOffset(tex1, ivec2(xv.y, yv.x), 0, ivec2(0,0))*1.0/8.0;
	c += texelFetchOffset(tex1, ivec2(xv.z, yv.x), 0, ivec2(0,0))*1.0/16.0;
	c += texelFetchOffset(tex1, ivec2(xv.x, yv.y), 0, ivec2(0,0))*1.0/8.0;
	c += texelFetchOffset(tex1, ivec2(xv.y, yv.y), 0, ivec2(0,0))*1.0/4.0;
	c += texelFetchOffset(tex1, ivec2(xv.z, yv.y), 0, ivec2(0,0))*1.0/8.0;
	c += texelFetchOffset(tex1, ivec2(xv.x, yv.z), 0, ivec2(0,0))*1.0/16.0;
	c += texelFetchOffset(tex1, ivec2(xv.y, yv.z), 0, ivec2(0,0))*1.0/8.0;
	c += texelFetchOffset(tex1, ivec2(xv.z, yv.z), 0, ivec2(0,0))*1.0/16.0;
	return c;
}

vec3 convertToUv(ivec3 data, float maxVal)
{
	return vec3(float(data.x)/maxVal, float(data.y)/maxVal, float(data.z)/maxVal);
}

vec4 altSimpleBlur(sampler2D tex1, vec2 ac, vec2 res)
{
	vec3 xv = convertToUv(clampedValues(int(ac.x), 0, int(res.x)), res.x);
	vec3 yv = convertToUv(clampedValues(int(ac.y), 0, int(res.y)), res.y);

	vec4 c = vec4(vec3(0.0), 1.0);
	c += texture(tex1, vec2(xv.x, yv.x))*1.0/16.0;
	c += texture(tex1, vec2(xv.y, yv.x))*1.0/8.0;
	c += texture(tex1, vec2(xv.z, yv.x))*1.0/16.0;
	c += texture(tex1, vec2(xv.x, yv.y))*1.0/8.0;
	c += texture(tex1, vec2(xv.y, yv.y))*1.0/4.0;
	c += texture(tex1, vec2(xv.z, yv.y))*1.0/8.0;
	c += texture(tex1, vec2(xv.x, yv.z))*1.0/16.0;
	c += texture(tex1, vec2(xv.y, yv.z))*1.0/8.0;
	c += texture(tex1, vec2(xv.z, yv.z))*1.0/16.0;
	return c;
}

void main( void ) {
	vec2 po = ( gl_FragCoord.xy / info.xy );
	//vec3 color = texture(half_tex, po).rgb;

	vec3 a = vec3(0.0);
	ivec2 pixelCoord = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y));

	//if ((pixelCoord.x % 2)-offset.x == 0 && (pixelCoord.y % 2)-offset.y == 0)
	//{
		//a = simpleBlur(half_tex, po).rgb;
		a = altSimpleBlur(half_tex, gl_FragCoord.xy, info.xy).rgb;
	/*}
	else
	{*/
	vec3 ao = texture(half_tex, po).rgb;
	//}
	vec3 b = texture(lastframe, po).rgb+vec3(0.05);
	// 1/(1 + abs(a-b)*cont)
	// 1/(1+(abs(a-b)/max(minimum,min(a,b)))*const)
	// square(1-abs(a-b)/max(a,b, minimum))

	// needs blur... just needs blur kernel

	vec3 difference = 1.0 /( 1.0 + abs(a-b)*100.0);
	//vec3 difference = 1.0 /( 1.0 + (abs(color-last)/max(vec3(0.1), min(color,last)))*1000.0);
	//vec3 difference = sqrt(1.0 - abs(a-b)/max(a,max(b,vec3(0.01))));

	//out_Color = vec4((color + last)/2.0*difference, 1.0);
	//out_Color = vec4((a+b)/2.0*difference, 1.0);
	//out_Color = vec4((a+b*difference),1.0);
	out_Color = vec4((a+b)*0.5, 1.0);
	/*
	ivec2 pixelCoord = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y));
	if ((pixelCoord.x % 2)-offset.x == 0 && (pixelCoord.y % 2)-offset.y == 0)
	{
		vec2 tsize2 = textureSize(lastframe, 0);
		ivec2 abscoord2 = ivec2(int(po.x * tsize2.x),int(po.y* tsize2.y) );
		vec4 lastColor = texelFetchOffset(lastframe, abscoord2, 0, ivec2(0,0));

		vec2 tsize = textureSize(half_tex, 0);
		ivec2 abscoord = ivec2(int(po.x * tsize.x),int(po.y* tsize.y) );
		vec4 rayColor = texelFetchOffset(half_tex, abscoord, 0, ivec2(0,0));
		out_Color = rayColor;
	}
	else
	{
		vec2 tsize = textureSize(lastframe, 0);
		ivec2 abscoord = ivec2(int(po.x * tsize.x),int(po.y* tsize.y) );
		out_Color = texelFetchOffset(lastframe, abscoord, 0, ivec2(0,0));
		//out_Color.r = 0.5;
		//out_Color.r += 0.5;
	}
	//out_Color.r += out_Color.w/5.0;
	//out_Color.w = 1.0;
	//out_Color = texture(half_tex, po);
	*/
}